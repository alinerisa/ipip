#!/bin/bash

# IPv6 sit + ipip6 Tunnel Manager üòé
# Multi-tunnel Iran <-> Foreign

SERVICE_NAME="tunnel-setup.service"
SCRIPT_PATH="/usr/local/bin/tunnel-setup.sh"
CONFIG_DIR="/etc/tunnel-manager"
CONFIG_FILE="${CONFIG_DIR}/config"

# Colors & styles
BOLD="\e[1m"
RESET="\e[0m"
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[33m"
CYAN="\e[36m"
MAGENTA="\e[35m"
GRAY="\e[90m"

CHECK="‚úÖ"
CROSS="‚ùå"
WARN="‚ö†Ô∏è"
INFO="‚ÑπÔ∏è"

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo -e "${RED}${CROSS} This script must be run as root (use sudo).${RESET}"
    exit 1
  fi
}

pause() {
  echo
  read -rp "Press Enter to return to the menu..." _
}

detect_local_ip() {
  local ip
  ip=$(ip -4 route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++){ if($i=="src"){print $(i+1); exit}}}')
  echo "$ip"
}

fix_dns_if_needed() {
  local resolv="/etc/resolv.conf"

  # ÿß⁄Øÿ± ŸÅÿß€åŸÑ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ¥ÿ™ÿå ⁄©ÿßÿ±€å ŸÜ⁄©ŸÜ
  [[ ! -f "$resolv" ]] && return

  # ÿß⁄Øÿ± 127.0.0.1 Ÿáÿ≥ÿ™ ŸàŸÑ€å 8.8.8.8 €åÿß 1.1.1.1 ŸÜ€åÿ≥ÿ™ÿå ŸÅŸÇÿ∑ ÿßŸàŸÜ‚ÄåŸàŸÇÿ™ ÿØÿ≥ÿ™ ÿ®ÿ≤ŸÜ
  if grep -qE '^\s*nameserver\s+127\.0\.0\.1' "$resolv" && \
     ! grep -qE '^\s*nameserver\s+(8\.8\.8\.8|1\.1\.1\.1)' "$resolv"; then

    echo -e "${INFO} Detected only 127.0.0.1 as DNS resolver. Adding a public fallback (8.8.8.8)..."

    cp "$resolv" "${resolv}.tunnel-backup.$(date +%s)"

    {
      echo "nameserver 8.8.8.8"
      echo "nameserver 1.1.1.1"
      cat "$resolv"
    } > "${resolv}.tmp" && mv "${resolv}.tmp" "$resolv"

    echo -e "${CHECK} DNS fallback added to /etc/resolv.conf (backup: ${resolv}.tunnel-backup.*).${RESET}"
  fi
}


print_banner() {
  clear
  echo -e "${MAGENTA}"
  cat << 'EOF'
 _______   _______         ______  _______  ______  _______  
|       \ |       \       |      \|       \|      \|       \ 
| $$$$$$$\| $$$$$$$\       \$$$$$$| $$$$$$$\\$$$$$$| $$$$$$$\
| $$__/ $$| $$  | $$        | $$  | $$__/ $$ | $$  | $$__/ $$
| $$    $$| $$  | $$        | $$  | $$    $$ | $$  | $$    $$
| $$$$$$$ | $$  | $$        | $$  | $$$$$$$  | $$  | $$$$$$$ 
| $$      | $$__/ $$       _| $$_ | $$      _| $$_ | $$      
| $$      | $$    $$      |   $$ \| $$     |   $$ \| $$      
 \$$       \$$$$$$$        \$$$$$$ \$$      \$$$$$$ \$$      
                                                             
                                                             
                                                             
EOF
  echo -e "${RESET}"
  echo -e "${BOLD}${CYAN}Tunnel Manager v1.0 (Multi-tunnel)${RESET}"
  echo -e "${GRAY}GitHub: github.com/alinerisa/ipip${RESET}"
  echo
}

ensure_script_header() {
  if [[ ! -f "$SCRIPT_PATH" ]]; then
    cat > "$SCRIPT_PATH" << 'EOF'
#!/bin/bash
set -e

# Auto-generated by tunnel-manager.sh

exit 0
EOF
    chmod +x "$SCRIPT_PATH"
  fi
}

append_block_file() {
  local block_file="$1"
  ensure_script_header
  sed -i '$d' "$SCRIPT_PATH"   # remove final exit 0
  echo >> "$SCRIPT_PATH"
  cat "$block_file" >> "$SCRIPT_PATH"
  echo >> "$SCRIPT_PATH"
  echo "exit 0" >> "$SCRIPT_PATH"
}

setup_systemd() {
  cat > "/etc/systemd/system/${SERVICE_NAME}" <<EOF
[Unit]
Description=Setup Network Tunnel
After=network.target

[Service]
ExecStart=${SCRIPT_PATH}
ExecReload=/bin/kill -HUP \$MAINPID
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "$SERVICE_NAME" >/dev/null 2>&1 || true
  systemctl restart "$SERVICE_NAME" || true
}

# ŸÖÿ≠ÿßÿ≥ÿ®Ÿá IPŸáÿß€å ÿØÿßÿÆŸÑ€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ Tunnel ID
compute_tunnel_params() {
  local tid="$1"
  local role="$2"

  # IPv4 /30
  local base_octet=$(( (tid - 1) * 4 ))
  local foreign_ipv4="192.168.13.$((base_octet + 1))"
  local iran_ipv4="192.168.13.$((base_octet + 2))"

  # IPv6: ÿ®ÿ±ÿß€å Ÿáÿ± ÿ™ŸàŸÜŸÑ €å⁄© /64 ÿ¨ÿØÿß
  # ŸÖÿ´ŸÑÿß:
  # Tunnel 1: fc00:1::1 (foreign), fc00:1::2 (iran)
  # Tunnel 2: fc00:2::1 (foreign), fc00:2::2 (iran)
  local foreign_v6="fc00:${tid}::1"
  local iran_v6="fc00:${tid}::2"

  if [[ "$tid" -eq 1 ]]; then
    TUN_NAME_SIT="6to4_PD_TUN"
    TUN_NAME_IPIP6="ip6PD_tun"
  else
    TUN_NAME_SIT="6to4_PD_TUN_${tid}"
    TUN_NAME_IPIP6="ip6PD_tun_${tid}"
  fi

  if [[ "$role" == "foreign" ]]; then
    TUN_LOCAL_IPV4="${foreign_ipv4}/30"
    TUN_REMOTE_IPV4="${iran_ipv4}"
    TUN_LOCAL_FC="${foreign_v6}"
    TUN_REMOTE_FC="${iran_v6}"
  else
    TUN_LOCAL_IPV4="${iran_ipv4}/30"
    TUN_REMOTE_IPV4="${foreign_ipv4}"
    TUN_LOCAL_FC="${iran_v6}"
    TUN_REMOTE_FC="${foreign_v6}"
  fi
}

install_or_update_tunnel() {
  mkdir -p "$CONFIG_DIR"

  print_banner
  echo -e "${BOLD}üöÄ Install / Update tunnel (by ID)${RESET}"
  echo "-----------------------------------"
  echo
  echo "Which server is this?"
  echo "  1) üåçüåê‚úÖ KHAREJ server"
  echo "  2) üü¢‚ö™Ô∏èüî¥ Iran server"
  read -rp "Choose your role [1-2]: " ROLE_CHOICE

  case "$ROLE_CHOICE" in
    1) ROLE="foreign" ; echo -e "${CHECK} Role set to: Foreign server" ;;
    2) ROLE="iran"    ; echo -e "${CHECK} Role set to: Iran server"    ;;
    *) echo -e "${RED}${CROSS} Invalid choice.${RESET}" ; return ;;
  esac

  echo "ROLE=${ROLE}" > "$CONFIG_FILE"
  
  if [[ "$ROLE" == "iran" ]]; then
    fix_dns_if_needed
  fi
  
  echo
  read -rp "Tunnel ID (integer ‚â• 1): " TID
  if ! [[ "$TID" =~ ^[0-9]+$ ]] || [[ "$TID" -lt 1 ]]; then
    echo -e "${RED}${CROSS} Invalid Tunnel ID.${RESET}"
    pause
    return
  fi

  compute_tunnel_params "$TID" "$ROLE"

  echo
  echo -e "${INFO} Calculated internal addresses for Tunnel ID ${TID}:"
  if [[ "$ROLE" == "foreign" ]]; then
    echo "  Local (Foreign): IPv6 ${TUN_LOCAL_FC}, IPv4 ${TUN_LOCAL_IPV4}"
    echo "  Remote (Iran):   IPv6 ${TUN_REMOTE_FC}, IPv4 ${TUN_REMOTE_IPV4}"
  else
    echo "  Local (Iran):    IPv6 ${TUN_LOCAL_FC}, IPv4 ${TUN_LOCAL_IPV4}"
    echo "  Remote (Foreign):IPv6 ${TUN_REMOTE_FC}, IPv4 ${TUN_REMOTE_IPV4}"
  fi
  echo

  echo -e "${INFO} Detecting local public IPv4..."
  LOCAL_IP=$(detect_local_ip)
  if [[ -z "$LOCAL_IP" ]]; then
    echo -e "${WARN} Could not auto-detect local IP."
    read -rp "Please enter this server's public IPv4: " LOCAL_IP
  else
    echo -e "${CHECK} Auto-detected local IP: ${LOCAL_IP}"
    read -rp "Press Enter if this is correct, or type another IPv4: " LOCAL_IP_OVERRIDE
    if [[ -n "$LOCAL_IP_OVERRIDE" ]]; then
      LOCAL_IP="$LOCAL_IP_OVERRIDE"
    fi
  fi
  if [[ -z "$LOCAL_IP" ]]; then
    echo -e "${RED}${CROSS} Local IP cannot be empty.${RESET}"
    pause
    return
  fi

  read -rp "Enter the public IPv4 of the opposite server: " REMOTE_IP
  if [[ -z "$REMOTE_IP" ]]; then
    echo -e "${RED}${CROSS} Remote IP cannot be empty.${RESET}"
    pause
    return
  fi

  # ---------- RUNTIME SETUP ----------
  echo
  echo -e "${INFO} Configuring runtime tunnel ${TUN_NAME_SIT}/${TUN_NAME_IPIP6} ..."
  ip tunnel del "$TUN_NAME_SIT" 2>/dev/null || true
  ip -6 tunnel del "$TUN_NAME_IPIP6" 2>/dev/null || true

  ip tunnel add "$TUN_NAME_SIT" mode sit remote "$REMOTE_IP" local "$LOCAL_IP"
  # ÿß€åŸÜÿ¨ÿß /64 ÿßÿÆÿ™ÿµÿßÿµ€å ÿ®ÿ±ÿß€å Ÿáÿ± ÿ™ŸàŸÜŸÑ
  ip -6 addr add "${TUN_LOCAL_FC}/64" dev "$TUN_NAME_SIT"
  ip link set "$TUN_NAME_SIT" mtu 1480
  ip link set "$TUN_NAME_SIT" up

  ip -6 tunnel add "$TUN_NAME_IPIP6" mode ipip6 remote "$TUN_REMOTE_FC" local "$TUN_LOCAL_FC"
  ip addr add "$TUN_LOCAL_IPV4" dev "$TUN_NAME_IPIP6"
  ip link set "$TUN_NAME_IPIP6" mtu 1440
  ip link set "$TUN_NAME_IPIP6" up

  # ---------- BLOCK FOR PERSISTENT SCRIPT ----------
  TMP_BLOCK=$(mktemp)
  cat > "$TMP_BLOCK" <<EOF
# Tunnel ID ${TID} (${ROLE})
ip tunnel del ${TUN_NAME_SIT} 2>/dev/null || true
ip -6 tunnel del ${TUN_NAME_IPIP6} 2>/dev/null || true

ip tunnel add ${TUN_NAME_SIT} mode sit remote ${REMOTE_IP} local ${LOCAL_IP}
ip -6 addr add ${TUN_LOCAL_FC}/64 dev ${TUN_NAME_SIT}
ip link set ${TUN_NAME_SIT} mtu 1480
ip link set ${TUN_NAME_SIT} up

ip -6 tunnel add ${TUN_NAME_IPIP6} mode ipip6 remote ${TUN_REMOTE_FC} local ${TUN_LOCAL_FC}
ip addr add ${TUN_LOCAL_IPV4} dev ${TUN_NAME_IPIP6}
ip link set ${TUN_NAME_IPIP6} mtu 1440
ip link set ${TUN_NAME_IPIP6} up
EOF

  # ---------- IRAN EXTRA (NAT + PORTS) ----------
  if [[ "$ROLE" == "iran" ]]; then
    if ! command -v iptables-save >/dev/null 2>&1; then
      echo -e "${RED}${CROSS} iptables-save is not available on this system.${RESET}"
      rm -f "$TMP_BLOCK"
      pause
      return
    fi

    echo
    echo -e "${INFO} This tunnel's remote internal IPv4: ${TUN_REMOTE_IPV4}"
    echo "Enter TCP ports to forward through this tunnel (unique across ALL tunnels)."
    echo "Example: 443,8080,2096  (or leave empty for no ports)"
    read -rp "TCP ports: " PORT_LIST_RAW

    echo >> "$TMP_BLOCK"
    cat >> "$TMP_BLOCK" <<'EOF'
# Enable IPv4 forwarding
sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true
EOF

    # Runtime sysctl + MASQUERADE
    sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true
    iptables -t nat -C POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup" 2>/dev/null || \
      iptables -t nat -A POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup"

    if [[ -n "$PORT_LIST_RAW" ]]; then
      CLEAN_PORTS=$(echo "$PORT_LIST_RAW" | tr -d '[:space:]')
      IFS=',' read -r -a PORT_ARRAY <<< "$CLEAN_PORTS"

      for PORT in "${PORT_ARRAY[@]}"; do
        [[ -z "$PORT" ]] && continue
        if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
          echo -e "${RED}${CROSS} Skipping invalid port: ${PORT}${RESET}"
          continue
        fi

        if iptables-save | grep -q "tunnel-setup" | grep -q -- "--dport ${PORT}"; then
          echo -e "${RED}${CROSS} Port ${PORT} is already used in some tunnel. Skipping.${RESET}"
          continue
        fi

        echo -e "${INFO} Adding DNAT rule for TCP port ${PORT} -> ${TUN_REMOTE_IPV4}"

        if iptables -t nat -A PREROUTING -p tcp --dport "${PORT}" -j DNAT --to-destination "${TUN_REMOTE_IPV4}" -m comment --comment "tunnel-setup" 2>/dev/null; then
          echo -e "${GREEN}${CHECK} Runtime rule added for port ${PORT}.${RESET}"

          cat >> "$TMP_BLOCK" <<EOF

# Tunnel ID ${TID}: TCP port ${PORT}
if ! iptables -t nat -C PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${TUN_REMOTE_IPV4} -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${TUN_REMOTE_IPV4} -m comment --comment "tunnel-setup"
fi
EOF

        else
          echo -e "${RED}${CROSS} Failed to add runtime rule for port ${PORT}.${RESET}"
        fi
      done
    fi

    cat >> "$TMP_BLOCK" <<'EOF'

# NAT for outgoing traffic (with comment for cleanup)
if ! iptables -t nat -C POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup"
fi
EOF
  fi

  append_block_file "$TMP_BLOCK"
  rm -f "$TMP_BLOCK"

  echo
  echo -e "${GREEN}${CHECK} Tunnel ID ${TID} (${ROLE}) configured and saved to ${SCRIPT_PATH}.${RESET}"
  echo -e "${INFO} Creating / updating systemd service and starting it...${RESET}"
  setup_systemd

  echo
  read -rp "Do you want to reboot the server now? [y/N]: " RB
  case "$RB" in
    y|Y|yes|YES)
      echo -e "${YELLOW}üîÅ Rebooting server...${RESET}"
      reboot
      ;;
    *)
      echo -e "${INFO} No reboot requested. Tunnels will be restored on next boot by systemd.${RESET}"
      ;;
  esac

  pause
}

status_tunnel() {
  print_banner
  echo -e "${BOLD}üß™ Tunnel status${RESET}"
  echo "-----------------"
  echo

  if systemctl list-unit-files | grep -q "^${SERVICE_NAME}"; then
    active_state=$(systemctl show -p ActiveState --value "$SERVICE_NAME" 2>/dev/null || echo "unknown")
    result=$(systemctl show -p Result --value "$SERVICE_NAME" 2>/dev/null || echo "unknown")
    enabled=$(systemctl is-enabled "$SERVICE_NAME" 2>/dev/null || echo "disabled")

    echo -n "Service: "

    if [[ "$active_state" == "active" ]]; then
      # ÿß⁄Øÿ± ÿ±Ÿàÿ≤€å Type ÿ±Ÿà simple ⁄©ÿ±ÿØ€å Ÿà ÿ≥ÿ±Ÿà€åÿ≥ ÿØÿ± ÿ≠ÿßŸÑ ÿßÿ¨ÿ±ÿß ÿ®ŸàÿØ
      echo -e "${GREEN}ACTIVE (running)${RESET} (${enabled}) ${CHECK}"
    elif [[ "$active_state" == "inactive" && "$result" == "success" && "$enabled" == "enabled" ]]; then
      # ÿßÿ≥⁄©ÿ±€åŸæÿ™ oneshot ÿßÿ¨ÿ±ÿß ÿ¥ÿØŸáÿå ŸÖŸàŸÅŸÇ ÿ®ŸàÿØŸáÿå ÿßŸÑÿßŸÜ ÿ∑ÿ®€åÿπ€å‚ÄåŸÄŸá ⁄©Ÿá inactive ÿ®ÿßÿ¥Ÿá
      echo -e "${GREEN}INSTALLED (oneshot, last run OK)${RESET} (${enabled}) ${CHECK}"
    elif [[ "$active_state" == "failed" || "$result" != "success" ]]; then
      echo -e "${RED}FAILED${RESET} (state: ${active_state}, result: ${result}, ${enabled}) ${CROSS}"
    else
      echo -e "${YELLOW}${active_state^^}${RESET} (result: ${result}, ${enabled}) ${WARN}"
    fi
  else
    echo -e "${RED}${CROSS} Service ${SERVICE_NAME} is not installed.${RESET}"
  fi

  echo
  echo "ip tunnel show:"
  ip tunnel show 2>/dev/null || echo "  (none)"

  echo
  echo "ip -6 tunnel show:"
  ip -6 tunnel show 2>/dev/null || echo "  (none)"

  echo
  echo "NAT rules with comment \"tunnel-setup\":"
  if command -v iptables-save >/dev/null 2>&1; then
    iptables-save | grep "tunnel-setup" || echo "  (no matching rules)"
  else
    echo "  iptables-save not available."
  fi

  pause
}


add_ports_menu() {
  print_banner
  echo -e "${BOLD}‚ûï Add TCP ports to existing tunnel (Iran only)${RESET}"
  echo "-----------------------------------------------"
  echo

  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo -e "${RED}${CROSS} No config file found. Please run Install/Update first.${RESET}"
    pause
    return
  fi

  # shellcheck disable=SC1090
  source "$CONFIG_FILE"

  if [[ "$ROLE" != "iran" ]]; then
    echo -e "${RED}${CROSS} This option is only valid on the Iran server.${RESET}"
    pause
    return
  fi

  if ! command -v iptables-save >/dev/null 2>&1; then
    echo -e "${RED}${CROSS} iptables-save is not available on this system.${RESET}"
    pause
    return
  fi

  read -rp "Tunnel ID to add ports to (integer ‚â• 1): " TID
  if ! [[ "$TID" =~ ^[0-9]+$ ]] || [[ "$TID" -lt 1 ]]; then
    echo -e "${RED}${CROSS} Invalid Tunnel ID.${RESET}"
    pause
    return
  fi

  compute_tunnel_params "$TID" "iran"
  REMOTE_IPV4_TUN="$TUN_REMOTE_IPV4"

  echo
  echo -e "${INFO} This tunnel's remote internal IPv4: ${REMOTE_IPV4_TUN}"
  echo "Enter additional TCP ports to forward (unique across ALL tunnels)."
  echo "Example: 443,8080,2096"
  read -rp "TCP ports: " NEW_PORTS

  if [[ -z "$NEW_PORTS" ]]; then
    echo -e "${WARN} No ports entered. Nothing to do.${RESET}"
    pause
    return
  fi

  if [[ ! -f "$SCRIPT_PATH" ]]; then
    echo -e "${RED}${CROSS} ${SCRIPT_PATH} not found. Please create at least one tunnel first.${RESET}"
    pause
    return
  fi

  CLEAN_PORTS=$(echo "$NEW_PORTS" | tr -d '[:space:]')
  IFS=',' read -r -a PORT_ARRAY <<< "$CLEAN_PORTS"

  sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true
  iptables -t nat -C POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup" 2>/dev/null || \
    iptables -t nat -A POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup"

  TMP_BLOCK=$(mktemp)
  cat > "$TMP_BLOCK" <<EOF

# Extra ports added later for Tunnel ID ${TID}
# Remote IPv4 inside tunnel:
# ${REMOTE_IPV4_TUN}
EOF

  for PORT in "${PORT_ARRAY[@]}"; do
    [[ -z "$PORT" ]] && continue
    if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}${CROSS} Skipping invalid port: ${PORT}${RESET}"
      continue
    fi

    if iptables-save | grep -q "tunnel-setup" | grep -q -- "--dport ${PORT}"; then
      echo -e "${RED}${CROSS} Port ${PORT} is already used in some tunnel. Skipping.${RESET}"
      continue
    fi

    echo -e "${INFO} Adding DNAT rule for TCP port ${PORT} -> ${REMOTE_IPV4_TUN}"

    if iptables -t nat -A PREROUTING -p tcp --dport "${PORT}" -j DNAT --to-destination "${REMOTE_IPV4_TUN}" -m comment --comment "tunnel-setup" 2>/dev/null; then
      echo -e "${GREEN}${CHECK} Runtime rule added for port ${PORT}.${RESET}"

      cat >> "$TMP_BLOCK" <<EOF

if ! iptables -t nat -C PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup"
fi
EOF
    else
      echo -e "${RED}${CROSS} Failed to add runtime rule for port ${PORT}.${RESET}"
    fi
  done

  append_block_file "$TMP_BLOCK"
  rm -f "$TMP_BLOCK"

  echo
  echo -e "${CHECK} Finished processing requested ports for Tunnel ID ${TID}.${RESET}"
  pause
}

uninstall_tunnel() {
  print_banner
  echo -e "${BOLD}üßπ Uninstall all tunnels${RESET}"
  echo "-------------------------"
  echo
  read -rp "Are you sure you want to remove ALL tunnels and service? [y/N]: " CONFIRM
  case "$CONFIRM" in
    y|Y|yes|YES) ;;
    *)
      echo -e "${INFO} Uninstall cancelled.${RESET}"
      pause
      return
      ;;
  esac

  echo
  echo -e "${INFO} Stopping and disabling service (if exists)..."
  systemctl stop "$SERVICE_NAME" 2>/dev/null || true
  systemctl disable "$SERVICE_NAME" 2>/dev/null || true
  rm -f "/etc/systemd/system/${SERVICE_NAME}"
  systemctl daemon-reload || true
  echo -e "${CHECK} Service removed."

  echo
  echo -e "${INFO} Deleting all tunnels (if exist)..."
  ip tunnel show | awk '{print $1}' | while read -r T; do
    ip tunnel del "$T" 2>/dev/null || true
  done
  ip -6 tunnel show 2>/dev/null | awk '{print $1}' | while read -r T; do
    ip -6 tunnel del "$T" 2>/dev/null || true
  done
  echo -e "${CHECK} Tunnel devices cleaned."

  echo
  echo -e "${INFO} Removing iptables rules with comment \"tunnel-setup\"..."
  if command -v iptables-save >/dev/null 2>&1; then
    iptables-save | awk '
      /^#/ {next}
      /^\*/ {table = substr($1,2); next}
      /^COMMIT/ {next}
      /tunnel-setup/ {
        gsub("^-A","-D");
        print table " " $0
      }
    ' | while read -r table rule; do
      iptables -t "$table" $rule 2>/dev/null || true
    done
    echo -e "${CHECK} iptables rules cleaned (where tagged)."
  else
    echo -e "${WARN} iptables-save not available, cannot auto-clean rules.${RESET}"
  fi

  echo
  echo -e "${INFO} Removing script and config..."
  rm -f "$SCRIPT_PATH" "$CONFIG_FILE" 2>/dev/null || true

  echo
  echo -e "${GREEN}${CHECK} All tunnels fully uninstalled.${RESET}"
  pause
}

print_menu() {
  echo "====================================="
  echo "  üåê IPv6 Tunnel Manager (sit+ipip6)"
  echo "====================================="
  echo "  1) üöÄ Install / Update tunnel (by ID)"
  echo "  2) üß™ Show tunnel status"
  echo "  3) ‚ûï Add TCP ports to existing tunnel (Iran only)"
  echo "  4) üßπ Uninstall all tunnels"
  echo "  5) ‚ùå Exit"
  echo
}

main_menu() {
  while true; do
    print_banner
    print_menu
    read -rp "Your choice [1-5]: " CHOICE

    case "$CHOICE" in
      1) install_or_update_tunnel ;;
      2) status_tunnel ;;
      3) add_ports_menu ;;
      4) uninstall_tunnel ;;
      5)
        echo
        echo -e "${CHECK} Goodbye! üëã${RESET}"
        exit 0
        ;;
      *)
        echo -e "${RED}${CROSS} Invalid choice. Please use 1-5.${RESET}"
        sleep 1.5
        ;;
    esac
  done
}

require_root
main_menu
